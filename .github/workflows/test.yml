name: test

on:
  push:
    branches:
      - main
    tags:
      - 'v*'
  workflow_dispatch:

env:
  REGISTRY_IMAGE: zhangdafei1995/my_ollvm
  TEST_TRIGGER_KEYWORDS: dotest
  TEST_IMAGE_TAG: latest
  OLLVM_FLAGS: "-mllvm -fla -mllvm -bcf -mllvm -sub -mllvm -split -mllvm -sobf"

jobs:
  smoke:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Determine smoke trigger
        id: smoke
        run: |
          set -euo pipefail
          RUN_SMOKE=false
          EVENT="${GITHUB_EVENT_NAME:-}"
          REF_TYPE="${GITHUB_REF_TYPE:-}"
          REF_NAME="${GITHUB_REF_NAME:-}"
          if [[ "$EVENT" == "push" && "$REF_TYPE" == "tag" && "$REF_NAME" == v* ]]; then
            RUN_SMOKE=true
          elif [[ "$EVENT" == "workflow_dispatch" ]]; then
            RUN_SMOKE=true
          else
            msg="$(git show -s --format=%B "${GITHUB_SHA}")"
            regex="$(printf '%s' "${TEST_TRIGGER_KEYWORDS:-}" | tr ' ' '|' )"
            if [[ -n "$regex" ]] && printf '%s\n' "$msg" | grep -Ei "$regex" >/dev/null; then
              RUN_SMOKE=true
            fi
          fi
          echo "run_smoke=$RUN_SMOKE" >> "$GITHUB_OUTPUT"

      - name: Skip non-release runs
        if: ${{ steps.smoke.outputs.run_smoke != 'true' }}
        run: echo "Skipping smoke tests for ${GITHUB_REF}; not a release tag or keyword-triggered commit."

      - name: Prepare artifact directory
        if: ${{ steps.smoke.outputs.run_smoke == 'true' }}
        run: |
          set -euo pipefail
          rm -rf artifacts
          mkdir -p artifacts

      - name: Set up Docker Buildx
        if: ${{ steps.smoke.outputs.run_smoke == 'true' }}
        uses: docker/setup-buildx-action@v3

      - name: Pull image
        if: ${{ steps.smoke.outputs.run_smoke == 'true' }}
        run: docker pull ${{ env.REGISTRY_IMAGE }}:${{ env.TEST_IMAGE_TAG }}

      - name: Verify UPX availability
        if: ${{ steps.smoke.outputs.run_smoke == 'true' }}
        run: >
          docker run --rm
          ${{ env.REGISTRY_IMAGE }}:${{ env.TEST_IMAGE_TAG }}
          bash -lc "set -euo pipefail; upx --version && upx -qq --help >/dev/null"

      - name: Rust toolchain builds
        if: ${{ steps.smoke.outputs.run_smoke == 'true' }}
        run: >-
          docker run --rm
          -v ${{ github.workspace }}/tests:/tests
          -v ${{ github.workspace }}/artifacts:/artifacts
          ${{ env.REGISTRY_IMAGE }}:${{ env.TEST_IMAGE_TAG }}
          bash -lc "set -euo pipefail;
          cd /tests/rust;
          CARGO_BIN=\"/opt/cargo/bin/cargo\";
          if [ ! -x \"\$CARGO_BIN\" ]; then
            CARGO_BIN=\"\$(command -v cargo)\";
          fi;
          OBF_FLAGS=\"${{ env.OLLVM_FLAGS }}\";
          \"\$CARGO_BIN\" clean;
          GNU_PLAIN=/tmp/rust_plain_gnu;
          GNU_OBF=/tmp/rust_obf_gnu;
          env OLLVM_MARK=plain OLLVM_EXTRA_FLAGS=\"\" CARGO_TARGET_DIR=\"\$GNU_PLAIN\" \"\$CARGO_BIN\" build --release;
          env OLLVM_MARK=obf OLLVM_EXTRA_FLAGS=\"\$OBF_FLAGS\" CARGO_TARGET_DIR=\"\$GNU_OBF\" CC=clang CFLAGS=\"\$OBF_FLAGS\" \"\$CARGO_BIN\" build --release;
          GNU_PLAIN_HASH=\"\$(sha256sum \"\$GNU_PLAIN/release/ollvm-smoke\" | awk '{print \$1}')\";
          GNU_OBF_HASH=\"\$(sha256sum \"\$GNU_OBF/release/ollvm-smoke\" | awk '{print \$1}')\";
          echo \"Rust GNU plain hash: \$GNU_PLAIN_HASH\";
          echo \"Rust GNU obf hash:   \$GNU_OBF_HASH\";
          if cmp -s \"\$GNU_PLAIN/release/ollvm-smoke\" \"\$GNU_OBF/release/ollvm-smoke\"; then
            echo 'Rust GNU binary unchanged under obfuscation flags' >&2
            exit 1
          fi;
          cp \"\$GNU_PLAIN/release/ollvm-smoke\" /artifacts/rust-linux-gnu-plain;
          cp \"\$GNU_OBF/release/ollvm-smoke\" /artifacts/rust-linux-gnu;
          MUSL_PLAIN=/tmp/rust_plain_musl;
          MUSL_OBF=/tmp/rust_obf_musl;
          env OLLVM_MARK=plain OLLVM_EXTRA_FLAGS=\"\" CARGO_TARGET_DIR=\"\$MUSL_PLAIN\" \"\$CARGO_BIN\" build --target x86_64-unknown-linux-musl --release;
          env OLLVM_MARK=obf OLLVM_EXTRA_FLAGS=\"\$OBF_FLAGS\" CARGO_TARGET_DIR=\"\$MUSL_OBF\" CC_x86_64_unknown_linux_musl=clang CFLAGS_x86_64_unknown_linux_musl=\"\$OBF_FLAGS\" \"\$CARGO_BIN\" build --target x86_64-unknown-linux-musl --release;
          MUSL_PLAIN_HASH=\"\$(sha256sum \"\$MUSL_PLAIN/x86_64-unknown-linux-musl/release/ollvm-smoke\" | awk '{print \$1}')\";
          MUSL_OBF_HASH=\"\$(sha256sum \"\$MUSL_OBF/x86_64-unknown-linux-musl/release/ollvm-smoke\" | awk '{print \$1}')\";
          echo \"Rust musl plain hash: \$MUSL_PLAIN_HASH\";
          echo \"Rust musl obf hash:   \$MUSL_OBF_HASH\";
          if cmp -s \"\$MUSL_PLAIN/x86_64-unknown-linux-musl/release/ollvm-smoke\" \"\$MUSL_OBF/x86_64-unknown-linux-musl/release/ollvm-smoke\"; then
            echo 'Rust musl binary unchanged under obfuscation flags' >&2
            exit 1
          fi;
          cp \"\$MUSL_PLAIN/x86_64-unknown-linux-musl/release/ollvm-smoke\" /artifacts/rust-linux-musl-plain;
          cp \"\$MUSL_OBF/x86_64-unknown-linux-musl/release/ollvm-smoke\" /artifacts/rust-linux-musl;
          if ! command -v /usr/bin/x86_64-w64-mingw32-gcc >/dev/null 2>&1; then
            echo 'Missing mingw toolchain in image; rebuild base image instead of installing ad-hoc packages.' >&2
            exit 1
          fi;
          WIN_LINKER=/usr/bin/x86_64-w64-mingw32-gcc;
          LIBGCC_DIR=\"\$(dirname \"\$(\"\$WIN_LINKER\" -print-libgcc-file-name)\")\";
          export LIBRARY_PATH=\"\$LIBGCC_DIR:\${LIBRARY_PATH:-}\";
          WIN_RUSTFLAGS=\"-Clinker-flavor=gcc -Clink-arg=-s\";
          WIN_PLAIN=/tmp/rust_plain_win;
          WIN_OBF=/tmp/rust_obf_win;
          env OLLVM_MARK=plain OLLVM_EXTRA_FLAGS=\"\" CARGO_TARGET_DIR=\"\$WIN_PLAIN\" CARGO_TARGET_X86_64_PC_WINDOWS_GNU_LINKER=\"\$WIN_LINKER\" CARGO_TARGET_X86_64_PC_WINDOWS_GNU_RUSTFLAGS=\"\$WIN_RUSTFLAGS\" \"\$CARGO_BIN\" build --target x86_64-pc-windows-gnu --release;
          env OLLVM_MARK=obf OLLVM_EXTRA_FLAGS=\"\$OBF_FLAGS\" CARGO_TARGET_DIR=\"\$WIN_OBF\" CARGO_TARGET_X86_64_PC_WINDOWS_GNU_LINKER=\"\$WIN_LINKER\" CARGO_TARGET_X86_64_PC_WINDOWS_GNU_RUSTFLAGS=\"\$WIN_RUSTFLAGS\" CC_x86_64_pc_windows_gnu=clang CFLAGS_x86_64_pc_windows_gnu=\"\$OBF_FLAGS\" \"\$CARGO_BIN\" build --target x86_64-pc-windows-gnu --release;
          WIN_PLAIN_HASH=\"\$(sha256sum \"\$WIN_PLAIN/x86_64-pc-windows-gnu/release/ollvm-smoke.exe\" | awk '{print \$1}')\";
          WIN_OBF_HASH=\"\$(sha256sum \"\$WIN_OBF/x86_64-pc-windows-gnu/release/ollvm-smoke.exe\" | awk '{print \$1}')\";
          echo \"Rust win plain hash: \$WIN_PLAIN_HASH\";
          echo \"Rust win obf hash:   \$WIN_OBF_HASH\";
          if cmp -s \"\$WIN_PLAIN/x86_64-pc-windows-gnu/release/ollvm-smoke.exe\" \"\$WIN_OBF/x86_64-pc-windows-gnu/release/ollvm-smoke.exe\"; then
            echo 'Rust Windows binary unchanged under obfuscation flags' >&2
            exit 1
          fi;
          cp \"\$WIN_PLAIN/x86_64-pc-windows-gnu/release/ollvm-smoke.exe\" /artifacts/rust-windows-plain.exe;
          cp \"\$WIN_OBF/x86_64-pc-windows-gnu/release/ollvm-smoke.exe\" /artifacts/rust-windows.exe"

      - name: Linux glibc and musl build
        if: ${{ steps.smoke.outputs.run_smoke == 'true' }}
        run: >-
          docker run --rm
          -v ${{ github.workspace }}/tests:/tests
          -v ${{ github.workspace }}/artifacts:/artifacts
          ${{ env.REGISTRY_IMAGE }}:${{ env.TEST_IMAGE_TAG }}
          bash -lc "set -euo pipefail;
          mkdir -p /artifacts;
          OBF_FLAGS=\"${{ env.OLLVM_FLAGS }}\";
          clang -O2 /tests/linux_glibc.c -o /tmp/linux_plain;
          clang \$OBF_FLAGS /tests/linux_glibc.c -O2 -o /artifacts/linux_glibc;
          GLIBC_PLAIN_HASH=\"\$(sha256sum /tmp/linux_plain | awk '{print \$1}')\";
          GLIBC_OBF_HASH=\"\$(sha256sum /artifacts/linux_glibc | awk '{print \$1}')\";
          echo \"glibc plain hash: \$GLIBC_PLAIN_HASH\";
          echo \"glibc obf hash:   \$GLIBC_OBF_HASH\";
          if cmp -s /tmp/linux_plain /artifacts/linux_glibc; then
            echo 'glibc binary unchanged under obfuscation flags' >&2
            exit 1
          fi;
          cp /tmp/linux_plain /artifacts/linux_glibc_plain;
          /artifacts/linux_glibc;
          clang --target=x86_64-linux-musl -isystem /usr/include/x86_64-linux-musl -L/usr/lib/x86_64-linux-musl -static -O2 /tests/linux_glibc.c -o /tmp/linux_musl_plain;
          clang --target=x86_64-linux-musl -isystem /usr/include/x86_64-linux-musl -L/usr/lib/x86_64-linux-musl -static \$OBF_FLAGS /tests/linux_glibc.c -O2 -o /artifacts/linux_musl;
          MUSL_PLAIN_HASH=\"\$(sha256sum /tmp/linux_musl_plain | awk '{print \$1}')\";
          MUSL_OBF_HASH=\"\$(sha256sum /artifacts/linux_musl | awk '{print \$1}')\";
          echo \"musl plain hash: \$MUSL_PLAIN_HASH\";
          echo \"musl obf hash:   \$MUSL_OBF_HASH\";
          if cmp -s /tmp/linux_musl_plain /artifacts/linux_musl; then
            echo 'musl binary unchanged under obfuscation flags' >&2
            exit 1
          fi;
          cp /tmp/linux_musl_plain /artifacts/linux_musl_plain;
          /artifacts/linux_musl"

      - name: Windows mingw build
        if: ${{ steps.smoke.outputs.run_smoke == 'true' }}
        run: >-
          docker run --rm
          -v ${{ github.workspace }}/tests:/tests
          -v ${{ github.workspace }}/artifacts:/artifacts
          ${{ env.REGISTRY_IMAGE }}:${{ env.TEST_IMAGE_TAG }}
          bash -lc "set -euo pipefail;
          mkdir -p /artifacts;
          OBF_FLAGS=\"${{ env.OLLVM_FLAGS }}\";
          x86_64-w64-mingw32-clang -O2 /tests/windows_hello.c -o /tmp/windows_plain.exe -luser32;
          x86_64-w64-mingw32-clang \$OBF_FLAGS /tests/windows_hello.c -O2 -o /artifacts/windows_hello.exe -luser32;
          WINC_PLAIN_HASH=\"\$(sha256sum /tmp/windows_plain.exe | awk '{print \$1}')\";
          WINC_OBF_HASH=\"\$(sha256sum /artifacts/windows_hello.exe | awk '{print \$1}')\";
          echo \"Windows C plain hash: \$WINC_PLAIN_HASH\";
          echo \"Windows C obf hash:   \$WINC_OBF_HASH\";
          if cmp -s /tmp/windows_plain.exe /artifacts/windows_hello.exe; then
            echo 'Windows binary unchanged under obfuscation flags' >&2
            exit 1
          fi;
          cp /tmp/windows_plain.exe /artifacts/windows_hello_plain.exe;
          llvm-readobj --file-headers /artifacts/windows_hello.exe | grep -q 'Machine: IMAGE_FILE_MACHINE_AMD64'"

      - name: Upload artifacts
        if: ${{ steps.smoke.outputs.run_smoke == 'true' }}
        uses: actions/upload-artifact@v4
        with:
          name: ollvm-binaries-${{ github.sha }}
          path: artifacts
